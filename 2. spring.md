#### I. Spring Core & Internals (1-15) - *Hiểu về cỗ máy*

1. **Inversion of Control (IoC)** và **Dependency Injection (DI)** khác nhau thế nào?
2. `ApplicationContext` khác gì `BeanFactory`? Tại sao Spring Boot dùng ApplicationContext?
3. Spring Bean mặc định là **Singleton**. Vậy nó có Thread-safe không? Làm sao để xử lý concurrent request vào 1 bean?
4. Giải thích vòng đời (Lifecycle) đầy đủ của một Spring Bean? (Instantiate -> Populate Properties -> Aware Methods -> PostProcessors -> Init -> Destroy).
5. `BeanPostProcessor` và `BeanFactoryPostProcessor` khác nhau thế nào?
6. Tại sao **Constructor Injection** được khuyên dùng hơn **Field Injection** (`@Autowired` trên field)?
7. Vấn đề **Circular Dependency** (A cần B, B cần A) xảy ra khi nào? Spring giải quyết nó ra sao? Khi nào Spring bó tay?
8. `@Component`, `@Repository`, `@Service`, `@Controller` khác nhau gì về mặt kỹ thuật (ngoài cái tên)?
9. Bean Scopes: `Singleton`, `Prototype`, `Request`, `Session`. Điều gì xảy ra nếu inject một `Prototype` bean vào một `Singleton` bean?
10. Spring AOP (Aspect Oriented Programming) hoạt động dựa trên cơ chế nào? (JDK Dynamic Proxy vs CGLIB).
11. Sự khác nhau giữa **Aspect**, **Pointcut**, **Advice**, và **JoinPoint**?
12. Tại sao gọi một hàm `@Transactional` từ một hàm khác *trong cùng một class* thì Transaction không hoạt động?
13. `@Qualifier` và `@Primary` dùng để làm gì khi có nhiều Bean cùng loại?
14. Spring profiles (`@Profile`) hoạt động thế nào?
15. Spring Expression Language (SpEL) là gì?

#### II. Spring Boot Magic (16-30)

16. Spring Boot khác gì Spring Framework thuần?
17. **Auto-configuration** hoạt động như thế nào? (Giải thích `@EnableAutoConfiguration` và file `spring.factories` hoặc `org.springframework.boot.autoconfigure.AutoConfiguration.imports` trong Spring Boot 3).
18. `@SpringBootApplication` bao gồm những annotation nào?
19. Embedded Web Server (Tomcat/Jetty) được khởi tạo ở giai đoạn nào?
20. Spring Boot Starter là gì? Nó quản lý version dependency như thế nào?
21. Cơ chế load cấu hình: Thứ tự ưu tiên của `application.properties`, biến môi trường (ENV), và command line arguments?
22. **Spring Boot Actuator** dùng để làm gì? Các endpoint quan trọng (`/health`, `/metrics`, `/dump`)?
23. Tại sao phải cẩn thận khi expose Actuator endpoints ra public internet?
24. Tạo một Custom Auto-Configuration như thế nào?
25. Sự khác nhau giữa file `.properties` và `.yaml`?
26. Làm sao để chạy code ngay sau khi Spring Boot app khởi động xong? (`CommandLineRunner` vs `ApplicationRunner`).
27. DevTools giúp gì cho developer? Cơ chế Restart vs Reload?
28. Quản lý log trong Spring Boot? (SLF4J, Logback).
29. Graceful Shutdown trong Spring Boot là gì?
30. Spring Boot hỗ trợ Docker hóa (Containerization) như thế nào (Buildpacks/Jib)?

#### III. Spring MVC & REST API (31-45)

31. Giải thích luồng đi của một Request trong Spring MVC (`DispatcherServlet`).
32. `@RestController` vs `@Controller`?
33. **Filters** (Servlet standard) vs **Interceptors** (Spring specific): Khác nhau gì? Thứ tự chạy?
34. `@RequestBody` và `@ResponseBody` hoạt động thế nào? (Cơ chế `HttpMessageConverter`).
35. `@PathVariable` vs `@RequestParam`?
36. Xử lý Exception tập trung: `@ControllerAdvice` và `@ExceptionHandler`.
37. Làm sao để validate input data? (`@Valid`, `@NotNull`, JSR-303).
38. Idempotency trong REST API là gì? Các method nào là Idempotent (GET, PUT, DELETE, POST)?
39. Sự khác nhau giữa PUT và PATCH?
40. Content Negotiation là gì? (Trả về JSON hay XML dựa trên Header `Accept`).
41. Versioning REST API: Có những cách nào? (URI versioning, Header versioning...).
42. HATEOAS là gì? Có thực sự cần thiết không?
43. CORS (Cross-Origin Resource Sharing) là gì? Config trong Spring Boot ra sao?
44. Asynchronous Request Processing trong Spring MVC (`Callable`, `DeferredResult`).
45. **Spring WebFlux**: Khi nào nên dùng Reactive Programming thay vì Blocking MVC?

#### IV. Spring Data JPA & Hibernate (46-75) - *Vùng "chết người" về performance*

46. JPA là gì? Hibernate là gì? Mối quan hệ giữa chúng?
47. **Entity Lifecycle**: Transient, Persistent, Detached, Removed. Chuyển trạng thái như thế nào?
48. `Session` (Hibernate) vs `EntityManager` (JPA)?
49. **N+1 Select Problem** là gì? Nguyên nhân và 3 cách khắc phục (Join Fetch, EntityGraph, BatchSize).
50. `LazyInitializationException` xảy ra khi nào? Cách fix?
51. **Lazy Loading** vs **Eager Loading**: Mặc định của `@OneToMany` và `@ManyToOne` là gì?
52. **Dirty Checking** của Hibernate hoạt động thế nào?
53. Hibernate **First-Level Cache** (Session cache) hoạt động ra sao? Có tắt được không?
54. **Second-Level Cache**: Khi nào nên dùng? (Redis/Ehcache).
55. `@Transactional`: Giải thích `Propagation.REQUIRED` vs `Propagation.REQUIRES_NEW`.
56. Transaction Isolation Levels trong Spring: `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`.
57. Điều gì xảy ra nếu Exception văng ra trong `@Transactional`? Checked Exception có rollback không?
58. **Optimistic Locking** (`@Version`) vs **Pessimistic Locking** (`SELECT ... FOR UPDATE`).
59. Sự khác nhau giữa `JpaRepository`, `CrudRepository` và `PagingAndSortingRepository`.
60. Derived Query Methods (ví dụ: `findByEmail`) hoạt động thế nào?
61. `@Query` (JPQL/HQL) vs Native Query? Khi nào dùng Native Query?
62. Criteria API là gì? Khi nào dùng?
63. Sự khác nhau giữa `CascadeType.ALL`, `PERSIST`, `REMOVE`?
64. `OrphanRemoval = true` khác gì với `CascadeType.REMOVE`?
65. Tại sao không nên dùng `@ManyToMany`? (Nên tách thành Entity trung gian).
66. Vấn đề hiệu năng khi dùng `@EqualsAndHashCode` của Lombok với JPA Entity?
67. Projection trong Spring Data JPA là gì? (DTO Projection vs Interface Projection).
68. Hibernate Batch Processing: Làm sao để insert 1000 records hiệu quả?
69. Soft Delete là gì? Implement trong JPA thế nào (`@SQLDelete`, `@Where`).
70. Auditing trong Spring Data JPA (`@CreatedDate`, `@LastModifiedBy`).
71. JPA Inheritance Strategies: `SINGLE_TABLE`, `JOINED`, `TABLE_PER_CLASS`. Ưu nhược điểm về perfomance?
72. Converter trong JPA dùng để làm gì? (Ví dụ: Map Enum hoặc JSON sang String).
73. Spring Data JDBC khác gì Spring Data JPA? Tại sao DDD (Domain Driven Design) lại thích JDBC hơn?
74. `@Modifying` dùng để làm gì?
75. Fetch Join vs Open Session In View (OSIV) pattern (Anti-pattern nổi tiếng).

#### V. Spring Security (76-85)

76. Cơ chế **Security Filter Chain** hoạt động như thế nào?
77. **Authentication** (Xác thực) vs **Authorization** (Phân quyền).
78. `UserDetailsService` và `UserDetails` interface.
79. Password Encoding: Tại sao dùng BCrypt/SCrypt mà không dùng MD5/SHA? Salt là gì?
80. **JWT (JSON Web Token)**: Cấu trúc Header, Payload, Signature.
81. Stateless Authentication (JWT) vs Stateful Authentication (Session-based). Ưu nhược điểm?
82. OAuth 2.0: Giải thích các flow (Authorization Code, Client Credentials).
83. Refresh Token dùng để làm gì? Lưu ở đâu an toàn (HttpOnly Cookie vs LocalStorage)?
84. CSRF (Cross-Site Request Forgery) là gì? Tại sao disable khi dùng API/JWT?
85. Method Security: `@PreAuthorize` vs `@Secured`.

#### VI. Database Deep Dive (86-100) - *Kiến thức nền tảng*

86. **ACID**: Atomicity, Consistency, Isolation, Durability. Giải thích từng cái.
87. **Index B-Tree** hoạt động thế nào? Tại sao tìm kiếm nhanh?
88. **Clustered Index** vs **Non-Clustered Index**?
89. **Composite Index** (Index nhiều cột): Quy tắc "Leftmost Prefix" là gì?
90. Tại sao dùng `SELECT *` lại tệ cho hiệu năng và Index?
91. **Execution Plan** (EXPLAIN): Bro đọc những thông số nào để tối ưu query? (Full Table Scan vs Index Scan).
92. **Database Normalization**: 1NF, 2NF, 3NF. Khi nào nên **Denormalize** (Phi chuẩn hóa)?
93. **Partitioning** (Horizontal Partitioning) vs **Sharding**?
94. **Database Locking**: Shared Lock (S) vs Exclusive Lock (X).
95. **Deadlock** trong Database: Ví dụ 1 kịch bản và cách phòng tránh.
96. **Connection Pool** (HikariCP): Tại sao cần nó? Config `maximumPoolSize` bao nhiêu là đủ?
97. **Stored Procedure**: Ưu và nhược điểm? Tại sao logic business nên để ở App thay vì DB?
98. **View** vs **Materialized View**?
99. UUID vs Auto Increment ID (Sequence) làm Primary Key? Vấn đề phân mảnh Index của UUID?
100. SQL Injection là gì? Cách phòng chống triệt để?