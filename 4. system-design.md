#### II. Distributed Systems & Performance (21-40)

21. **CAP Theorem**: Consistency, Availability, Partition Tolerance. Bro chọn 2 cái nào trong hệ thống của bro? (Thường là CP hoặc AP).
22. **PACELC Theorem**: Mở rộng của CAP khi hệ thống bình thường (không có Partition) thì chọn Latency hay Consistency?
23. **Eventual Consistency** vs **Strong Consistency**?
24. **Load Balancing**: Layer 4 (Transport) vs Layer 7 (Application) Load Balancer. Nginx/HAProxy hoạt động ở đâu?
25. **Sticky Session** trong Load Balancing là gì? Tại sao nó gây khó khăn cho Scaling?
26. **Consistent Hashing**: Tại sao dùng nó để chia tải (sharding) thay vì Modulo hashing?
27. **Idempotency**: Làm sao để đảm bảo an toàn khi client retry API Payment (POST method)? (Idempotency Key).
28. **Distributed Tracing**: Làm sao trace 1 request đi qua 10 services? (TraceID, SpanID - Zipkin/Jaeger).
29. **Distributed Locking**: Làm sao để lock 1 resource giữa nhiều instance? (Redis Redlock, Zookeeper).
30. **Rate Limiting Algorithms**: Token Bucket, Leaky Bucket, Fixed Window, Sliding Window Log.
31. **Throttling** vs **Rate Limiting**?
32. **Caching Strategy**: Cache-Aside, Read-Through, Write-Through, Write-Back (Write-Behind).
33. **Cache Eviction Policies**: LRU (Least Recently Used), LFU (Least Frequently Used).
34. **Cache Stampede** (Dogpile Effect): Khi cache hết hạn và hàng ngàn request ập vào DB. Cách xử lý?
35. **Bloom Filter**: Làm sao để check nhanh một phần tử *có thể* tồn tại hay *chắc chắn không* tồn tại? (Dùng để giảm tải cho DB).
36. **CDN (Content Delivery Network)** hoạt động thế nào? Push CDN vs Pull CDN.
37. **Database Sharding**: Key-based (Hash) sharding vs Range-based sharding vs Directory-based sharding.
38. **Replication**: Master-Slave vs Master-Master replication. Vấn đề replication lag?
39. **Snowflake ID** (Twitter): Cấu trúc tạo unique ID phân tán (Timestamp + MachineID + Sequence).
40. **Heartbeat** mechanism để detect node failure.

#### III. Messaging & Event-Driven (Kafka/RabbitMQ) (41-55)

41. **Synchronous** (REST/gRPC) vs **Asynchronous** (Message Queue) communication. Khi nào dùng cái nào?
42. **Kafka** vs **RabbitMQ**: Kiến trúc Push vs Pull? Throughput vs Latency?
43. **Kafka Architecture**: Topic, Partition, Broker, Zookeeper/KRaft.
44. **Consumer Group** trong Kafka dùng để làm gì? Làm sao để scale consumer?
45. Làm sao đảm bảo **thứ tự message** trong Kafka? (Partition Key).
46. **Exactly-once delivery** semantics: Có thật không? Làm sao đạt được?
47. **Message Durability**: Message lưu trên ổ cứng hay RAM?
48. **Dead Letter Queue (DLQ)**: Xử lý message lỗi như thế nào?
49. **Backpressure**: Khi Consumer xử lý chậm hơn Producer đẩy tin, hệ thống xử lý sao?
50. RabbitMQ Exchange types: Direct, Fanout, Topic, Headers.
51. **Event Schema Registry** (Avro/Protobuf): Tại sao cần nó để quản lý version message?
52. **Log Compaction** trong Kafka là gì?
53. **Ack modes**: Auto-ack vs Manual-ack. Rủi ro mất message?
54. **Pub/Sub pattern** vs **Message Queuing pattern**.
55. Long Polling vs WebSockets vs Server-Sent Events (SSE).

#### V. System Design Scenarios (76-90) - *Thực chiến thiết kế*

*Yêu cầu: Thiết kế High Level (HLD) & Low Level (LLD)*
76. Design **URL Shortener** (TinyURL). (Hash collision, Database choice).
77. Design **Rate Limiter**. (Distributed counter, Redis Lua script).
78. Design **Notification System**. (Push, Email, SMS, Queue prioritization).
79. Design **Chat System** (Messenger/WhatsApp). (WebSocket, Msg persistence, Online status).

80. Design **E-commerce Order System**. (Inventory check, Locking, Payment integration).
81. Design **Twitter/News Feed**. (Fan-out on write vs Fan-out on read).
82. Design **Typeahead Suggestion** (Google Search bar). (Trie data structure).
83. Design **YouTube/Netflix**. (Video chunking, CDN, Adaptive streaming).
84. Design **Web Crawler**. (Politeness, Deduplication, Distributed queue).
85. Design **Grab/Uber** (Ride Hailing). (Geo-hashing, QuadTree for location).
86. Design **Leaderboard** (Game Ranking). (Redis Sorted Set).
87. Design **Unique ID Generator**.
88. Design **Distributed Job Scheduler**.
89. Design **Google Drive/Dropbox** (File sync, Chunking, Hashing).
90. Design **Ticket Booking System** (Concert/Cinema). (Concurrency handling).

#### VI. Behavioral & Leadership (91-100) - *Định vị Senior*

91. Kể về một **Production Incident** lớn nhất bro từng gặp. Bro đã debug, fix và **ngăn chặn** nó tái diễn như thế nào? (Post-mortem).
92. Làm sao bro thuyết phục team chuyển từ công nghệ A sang công nghệ B (ví dụ: Monolith sang Microservices)?
93. Bro handle **Technical Debt** như thế nào? Khi nào nên refactor, khi nào nên viết mới?
94. Làm sao bro mentor một Junior dev? Bro code review như thế nào để họ không cảm thấy bị "bắt bẻ"?
95. Khi Product Owner yêu cầu một tính năng kỹ thuật "bất khả thi" hoặc deadline vô lý, bro làm gì?
96. Bro cập nhật công nghệ mới bằng cách nào? (Blogs, Conferences, Pet projects).
97. Giải thích một khái niệm kỹ thuật phức tạp cho người phi kỹ thuật (Non-tech stakeholder).
98. Bro ưu tiên **Code Quality** hay **Delivery Speed**? Làm sao để cân bằng?
99. Kể về một lần bro bất đồng quan điểm với Sếp hoặc Tech Lead. Bro xử lý ra sao?
100. **Tại sao công ty nên tuyển bro vào vị trí Senior với mức lương này?** (Giá trị bro mang lại là gì?).