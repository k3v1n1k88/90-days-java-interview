1. **Decomposition Strategies:** Khi tách Monolith, bro dùng chiến lược nào? (Decompose by Business Capability vs Decompose by Subdomain).
2. **Strangler Fig Pattern:** Làm sao để thay thế dần hệ thống cũ bằng Microservices mà không đập đi xây lại từ đầu?
3. **Database per Service:** Ưu điểm thì rõ rồi, nhưng nhược điểm lớn nhất là gì? (Cross-service joins, Distributed Transaction). Bro giải quyết thế nào?
4. **Saga Pattern (Deep dive):** Xử lý rollback (Compensating Transaction) như thế nào nếu bước thứ 5/10 bị lỗi? Dữ liệu rác xử lý sao?
5. **CQRS & Event Sourcing:** Tại sao Event Sourcing lại giúp debug hệ thống dễ hơn? Replay event là gì?
6. **BFF (Backend for Frontend):** Khi nào cần tách BFF cho Mobile riêng và Web riêng?
7. **API Gateway:** So sánh Kong, Nginx và Spring Cloud Gateway. Khi nào nên dùng loại nào?
8. **Service Mesh (Istio/Linkerd):** Tại sao cần Service Mesh thay vì dùng thư viện (như Resilience4j) trong code? (Sidecar proxy pattern).
9. **Externalized Configuration:** Làm sao để đổi config của 50 services cùng lúc mà không restart? (Spring Cloud Config / Consul / K8s ConfigMap).
10. **Consumer Driven Contract (Pact):** Làm sao để Frontend và Backend test tích hợp mà không cần deploy môi trường thật?
11. **Bulkhead Pattern:** Thiết kế Thread Pool riêng biệt cho từng service dependency như thế nào để tránh lỗi dây chuyền?
12. **Health Check API:** Sự khác nhau giữa `Liveness`, `Readiness` và `Startup` probe? K8s dùng chúng để làm gì?
13. **Sidecar Pattern:** Ứng dụng thực tế ngoài Service Mesh? (Log shipping, Authentication proxy).
14. **Ambassador Pattern:** Dùng container phụ để handle kết nối legacy hoặc network phức tạp ra sao?
15. **Leader Election:** Trong một cluster các instances, làm sao chọn ra 1 thằng làm "Leader" để chạy Cron Job? (Dùng Redis, Zookeeper hay K8s Lease?).
16. **Anti-Corruption Layer (ACL):** Bảo vệ Microservices mới khỏi mô hình dữ liệu quái dị của Legacy System như thế nào?
17. **Discovery Server:** Tại sao trong môi trường K8s (Kubernetes) lại không cần Eureka server nữa? (K8s Service DNS).
18. **Idempotency Key:** Thiết kế API Payment an toàn tuyệt đối khi mạng chập chờn?
19. **Graceful Shutdown:** Làm sao để service hoàn thành nốt request đang chạy trước khi bị K8s kill? (SIGTERM signal handling).
20. **Distributed Caching:** Vấn đề "Near Cache" (Local cache trên mỗi instance) kết hợp với Redis Remote Cache? Làm sao sync?

#### II. Cloud Infrastructure & Kubernetes (21-50)

21. **IaaS vs PaaS vs SaaS vs FaaS:** Phân biệt nhanh và ví dụ.
22. **Immutable Infrastructure:** Tại sao không nên SSH vào server để sửa config? (Packer, Terraform).
23. **Kubernetes Architecture:** Giải thích vai trò của etcd, API Server, Scheduler, Kubelet.
24. **Pod vs Node:** Một Pod chứa nhiều Container được không? Khi nào nên làm vậy?
25. **Service Types:** ClusterIP vs NodePort vs LoadBalancer vs ExternalName.
26. **Ingress Controller:** Nginx Ingress hoạt động thế nào? Sự khác nhau giữa Ingress và API Gateway?
27. **Persistent Volume (PV) & PVC:** Làm sao để lưu dữ liệu database bền vững trong K8s khi Pod có thể chết bất cứ lúc nào?
28. **StatefulSet vs Deployment:** Tại sao chạy Database/Kafka trên K8s lại khó hơn chạy Stateless App? (Headless Service, Ordered start).
29. **Horizontal Pod Autoscaler (HPA):** Scale dựa trên CPU/RAM là bình thường. Scale dựa trên số lượng request (RPS) hoặc độ dài hàng đợi (Queue size) kiểu gì? (KEDA).
30. **Helm Charts:** Quản lý version của ứng dụng và dependencies trong K8s.
31. **Operator Pattern:** K8s Operator là gì? Tại sao nên dùng Prometheus Operator thay vì cài thủ công?
32. **Network Policy:** Làm sao cấm Service A gọi Service B trong K8s? (Firewall ở level Pod).
33. **Cloud Load Balancing:** Sự khác nhau giữa Layer 4 (NLB) và Layer 7 (ALB) trên AWS/GCP?
34. **Spot Instances (AWS) / Preemptible VMs (GCP):** Làm sao để tiết kiệm 70% chi phí server nhưng vẫn đảm bảo hệ thống không sập khi server bị thu hồi?
35. **Multi-Cloud / Hybrid Cloud:** Thách thức lớn nhất khi chạy app vừa trên AWS vừa on-premise là gì? (Latency, Data Gravity).
36. **CDN (CloudFront/Cloudflare):** Cache Invalidations hoạt động thế nào?
37. **Object Storage (S3):** Consistency Model của S3 là gì? (Strong consistency after write).
38. **Cold Start:** Vấn đề này trong AWS Lambda/Serverless là gì? Cách khắc phục? (Provisioned Concurrency, GraalVM).
39. **VPC Peering vs VPN:** Kết nối các mạng riêng ảo với nhau.
40. **Infrastructure as Code (IaC):** Terraform State Management (Locking, Remote Backend).

#### III. Communication & Messaging (51-70)

41. **REST vs gRPC:** Tại sao gRPC nhanh hơn? (Protobuf binary vs JSON text, HTTP/2 multiplexing).
42. **gRPC Streaming:** Unary vs Server Streaming vs Client Streaming vs Bidirectional Streaming. Khi nào dùng?
43. **Message Queue vs Pub/Sub:** Sự khác nhau cơ bản?
44. **Kafka vs RabbitMQ (Cloud context):** Amazon MSK (Managed Kafka) vs Amazon MQ. Khi nào tự host, khi nào dùng managed?
45. **Schema Registry:** Quản lý thay đổi cấu trúc message (Avro schemas) để tránh break consumer.
46. **Dead Letter Queue (DLQ):** Chiến lược retry (Exponential Backoff) và xử lý tin nhắn chết.
47. **Outbox Pattern:** Đảm bảo tính toàn vẹn dữ liệu khi vừa ghi vào DB vừa bắn message ra Kafka. (Tránh Dual Write problem).
48. **Event Driven Architecture:** Sự khác nhau giữa Event Notification (báo thay đổi) và Event-Carried State Transfer (gửi kèm dữ liệu).
49. **Webhooks:** Thiết kế hệ thống Webhook để gửi thông báo cho bên thứ 3 (Retry, Security signature).
50. **GraphQL:** Tại sao GraphQL giúp giảm over-fetching/under-fetching trong môi trường Microservices? Vấn đề N+1 query trong GraphQL giải quyết sao?

#### IV. Observability & Monitoring (71-85)

51. **The 3 Pillars:** Logs, Metrics, Traces. Mối liên hệ giữa chúng?
52. **Distributed Tracing:** OpenTelemetry là gì? Làm sao để truyền Trace Context (TraceID) qua Kafka message?
53. **Log Aggregation:** ELK Stack (Elasticsearch, Logstash, Kibana) vs EFK (Fluentd) vs PLG (Promtail, Loki, Grafana). Tại sao Loki tiết kiệm chi phí hơn?
54. **Prometheus Architecture:** Pull-based monitoring hoạt động thế nào?
55. **Push Gateway:** Khi nào cần push metric thay vì để Prometheus pull? (Short-lived jobs).
56. **Service Level Objectives (SLO) / SLA / SLI:** Phân biệt 3 khái niệm này. Error Budget là gì?
57. **Synthetic Monitoring:** Giả lập hành vi user để check uptime hệ thống.
58. **Alerting:** Làm sao để group các alert (AlertManager) để không bị spam email khi một cụm server sập?
59. **Correlation ID:** Tầm quan trọng của việc có 1 ID duy nhất xuyên suốt từ Nginx -> Gateway -> Service A -> Service B -> DB Log.
60. **Chaos Engineering:** Dùng Chaos Mesh hoặc Gremlin để test khả năng phục hồi của hệ thống trên K8s.

#### V. Security & Identity (86-100)

61. **Zero Trust Security:** Tại sao không nên tin tưởng mạng nội bộ (LAN)?
62. **mTLS (Mutual TLS):** Xác thực 2 chiều giữa các services. Istio giúp việc này như thế nào?
63. **OAuth2 & OIDC:** Sự khác nhau giữa Access Token và ID Token.
64. **JWT (JSON Web Token):** Stateless authentication. Làm sao thu hồi (revoke) 1 JWT khi nó chưa hết hạn? (Blacklist/Redis).
65. **Keycloak / Auth0:** Dùng Identity Provider (IdP) tập trung quản lý user.
66. **Role Based Access Control (RBAC):** Cấp quyền trong K8s như thế nào? (ServiceAccount, Role, RoleBinding).
67. **Secrets Management:** Tại sao không nên commit password vào Git? Dùng Vault (HashiCorp) hoặc AWS Secrets Manager thế nào?
68. **DDoS Protection:** Rate Limiting ở Gateway và WAF (Web Application Firewall) trên Cloud.
69. **Container Security:** Quét lỗ hổng Image (Trivy/Clair). Không chạy container với quyền root.
70. **SPIFFE/SPIRE:** Định danh cho workload trong môi trường Cloud Native động.