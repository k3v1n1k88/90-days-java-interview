#### I. OOP & Fundamental (1-15)

1. Tại sao Java không hỗ trợ đa kế thừa (Multiple Inheritance) bằng class?
2. Java là "Pass-by-value" hay "Pass-by-reference"? Chứng minh?
3. Tại sao method `main` phải là `static`?
4. Tính đa hình (Polymorphism) runtime hoạt động thế nào? (Gợi ý: Virtual Method Invocation).
5. Co-variant return type là gì?
6. Sự khác nhau giữa Abstract Class và Interface (Về mặt thiết kế, không phải cú pháp)?
7. Default method trong Interface (Java 8) sinh ra để giải quyết vấn đề gì?
8. Sự khác nhau giữa `overloading` và `overriding`? Cái nào là Static Binding, cái nào là Dynamic Binding?
9. Class `Object` có những method nào? Kể tên ít nhất 5 cái.
10. Contract giữa `equals()` và `hashCode()` là gì? Chuyện gì xảy ra nếu override `equals` mà quên `hashCode`?
11. Clone object: Deep copy vs Shallow copy?
12. Marker Interface là gì? Kể tên 2 cái trong JDK.
13. Tại sao không nên dùng `finalize()`? (Nó đã bị Deprecated).
14. Static block chạy khi nào? Thứ tự chạy của static block, init block và constructor?
15. `Composition` vs `Inheritance`: Tại sao nên ưu tiên Composition?

#### II. String & Immutable (16-25)

16. Tại sao `String` lại là Immutable? (Về Security, Thread-safety, Hashcode caching).
17. `String s = "abc"` và `String s = new String("abc")` tạo ra bao nhiêu object? Ở đâu trong bộ nhớ?
18. `intern()` method của String hoạt động thế nào?
19. Tại sao mảng `char[]` được ưu tiên hơn `String` để lưu password?
20. `StringBuilder` vs `StringBuffer`: Cái nào Thread-safe?
21. String Constant Pool nằm ở đâu trong bộ nhớ (Java 6 vs Java 7+)?
22. Toán tử `+` khi nối chuỗi được biên dịch thành gì?
23. String Deduplication trong G1 GC là gì?
24. Class `Wrapper` (Integer, Long...) có Immutable không?
25. Integer Cache (từ -128 đến 127) hoạt động thế nào?

#### III. Collections & Generics (26-45)

26. Hierarchy của Collection Framework? (Sự khác biệt giữa Collection và Collections).
27. `ArrayList` resize như thế nào khi full capacity?
28. `LinkedList` vs `ArrayList`: Về mặt Memory locality và CPU Cache?
29. Cơ chế hoạt động của `HashMap` (Put & Get).
30. Khi nào `HashMap` chuyển từ LinkedList sang Red-Black Tree? (Ngưỡng TREEIFY_THRESHOLD).
31. Tại sao `String` là key tốt nhất cho `HashMap`?
32. Điều gì xảy ra nếu 2 object có cùng hashCode đưa vào HashMap? (Collision handling).
33. `Fail-fast` iterator vs `Fail-safe` iterator?
34. `HashSet` khử trùng lặp như thế nào? (Bên dưới nó chạy cái gì?).
35. `LinkedHashMap` duy trì thứ tự chèn như thế nào? Dùng nó để làm Cache LRU ra sao?
36. `TreeMap` dùng cấu trúc dữ liệu gì? Key trong TreeMap có được null không?
37. `IdentityHashMap` vs `HashMap`?
38. `WeakHashMap` hoạt động thế nào? Khi nào dùng nó?
39. Generics: Type Erasure là gì?
40. Tại sao không thể tạo mảng Generic (`new T[]`)?
41. Wildcard `? extends T` và `? super T` (PECS principle) dùng khi nào?
42. `PriorityQueue` dùng cấu trúc dữ liệu gì? (Binary Heap).
43. `Arrays.sort()` dùng thuật toán gì cho Primitive và Object? (Dual-Pivot Quicksort vs Timsort).
44. `Collections.unmodifiableList()` trả về cái gì? Có thêm sửa xóa được không?
45. `CopyOnWriteArrayList`: Tại sao nó Thread-safe mà không cần lock khi đọc?

#### IV. Exception Handling (46-55)

46. Hierarchy của Exception? `Error` vs `Exception`.
47. Checked vs Unchecked Exception: Triết lý thiết kế?
48. `try-with-resources` hoạt động thế nào? (Interface `AutoCloseable`).
49. `finally` block có luôn luôn chạy không? Khi nào nó không chạy?
50. Nếu `try` có return và `finally` cũng có return, cái nào được trả về?
51. Exception Swallowing là gì? Tại sao nguy hiểm?
52. Custom Exception: Khi nào nên tạo?
53. `throw` vs `throws`?
54. Multi-catch block trong Java 7+.
55. StackTrace lưu thông tin gì? Chi phí tạo Exception có tốn kém không?

#### V. Concurrency & Multithreading (56-80) - *Phần quan trọng nhất cho Senior*

56. Lifecycle của một Thread?
57. `wait()` và `notify()` tại sao lại nằm ở class Object mà không phải Thread?
58. Spurious Wakeup là gì? Tại sao phải dùng vòng lặp `while` khi check condition wait?
59. `sleep()` vs `wait()`?
60. `join()` method dùng để làm gì?
61. Deadlock là gì? Làm sao để detect và prevent?
62. Livelock và Starvation là gì?
63. Race Condition là gì? Critical Section là gì?
64. `synchronized` block vs `synchronized` method?
65. Lock level: Class level lock vs Object level lock.
66. `Volatile` keyword: Visibility problem & Instruction Reordering.
67. Java Memory Model (JMM): Quy tắc "Happens-Before".
68. `ReentrantLock` vs `synchronized`: Ưu nhược điểm?
69. `Condition` trong Lock dùng để làm gì?
70. `ReadWriteLock`: Khi nào nên dùng?
71. `StampedLock` (Java 8) khác gì `ReadWriteLock`? (Optimistic locking).
72. `CountDownLatch` vs `CyclicBarrier`?
73. `Semaphore` dùng để làm gì?
74. `ThreadLocal`: Tại sao phải remove sau khi dùng (Memory Leak issue)?
75. `ExecutorService`: Các loại ThreadPool (Fixed, Cached, Single, Scheduled).
76. `ForkJoinPool`: Work-stealing algorithm là gì?
77. `Callable` vs `Runnable`?
78. `Future` và nhược điểm của nó?
79. `CompletableFuture`: Chaining, Error handling, Combining futures.
80. **Project Loom**: Virtual Threads là gì? Khác gì Platform Threads (OS Threads)?

#### VI. JVM Internals & GC (81-90)

81. Cấu trúc JVM: ClassLoader, Runtime Data Areas, Execution Engine.
82. Các loại ClassLoader (Bootstrap, Extension/Platform, Application).
83. Cơ chế Delegation Model của ClassLoader?
84. Stack Memory vs Heap Memory: Biến local lưu ở đâu, Object lưu ở đâu?
85. Metaspace (Java 8) thay thế PermGen như thế nào?
86. Garbage Collection Root (GC Root) là gì?
87. Các thuật toán GC: Mark-Sweep, Mark-Compact, Copying.
88. Generational GC: Eden, Survivor S0/S1, Old Gen. Flow của một object?
89. Stop-the-world (STW) event là gì?
90. So sánh G1 GC, ZGC và Shenandoah GC (Low latency GCs).
91. Lambda Expression được compile thành gì? (invokedynamic).
92. Functional Interface: `Predicate`, `Consumer`, `Supplier`, `Function`.
93. Stream API: Intermediate vs Terminal operations.
94. Lazy Evaluation trong Stream là gì?
95. `ParallelStream`: Nguy cơ khi sử dụng (Common ForkJoinPool).
96. `Optional`: Khi nào nên dùng, khi nào không? (Đừng dùng làm tham số method).
97. Java 9 Modules (JPMS) là gì?
98. `var` (Local Variable Type Inference) trong Java 10.
99. Java Records (Java 14/16): Khác gì class thường?
100. Sealed Classes (Java 17): Kiểm soát kế thừa như thế nào?