1. **Index Internals:** Cấu trúc vật lý của B+ Tree khác gì B-Tree? Tại sao B+ Tree lại tối ưu cho range query (tìm kiếm trong khoảng)?
2. **Page/Block:** Dữ liệu trong Database được lưu trữ vật lý như thế nào trên ổ cứng? Khái niệm "Page Splitting" là gì và tại sao nó gây chậm?
3. **Covering Index:** Làm sao để query lấy dữ liệu *chỉ từ Index* mà không cần truy cập vào bảng chính (Heap)?
4. **Cardinality:** Độ phân tán dữ liệu ảnh hưởng thế nào đến quyết định dùng Index của DB Optimizer?
5. **Explain Analyze:** Khi đọc Execution Plan, bro quan tâm đến thông số nào nhất? (Cost, Rows, Filter, Hit Ratio?).
6. **Table Scan vs Index Scan:** Có trường hợp nào Index Scan lại chậm hơn Full Table Scan không?
7. **Partitioning Pruning:** DB loại bỏ các partition không cần thiết như thế nào khi query?
8. **MVCC (Multi-Version Concurrency Control):** Postgres/MySQL xử lý việc đọc/ghi đồng thời mà không lock toàn bảng như thế nào?
9. **VACUUM (Postgres):** Tại sao update/delete trong Postgres tạo ra "dead tuples"? Hậu quả nếu không chạy Vacuum?
10. **WAL (Write-Ahead Logging):** Tại sao DB ghi log trước khi ghi dữ liệu vào ổ cứng? Nó đảm bảo tính Durability (trong ACID) ra sao?
11. **Checkpoint:** Quá trình Checkpoint hoạt động thế nào để đồng bộ dữ liệu từ RAM xuống đĩa?
12. **Buffer Pool:** Làm sao để tối ưu dung lượng RAM cho Buffer Pool (MySQL) hoặc Shared Buffers (Postgres)?
13. **Isolation Levels Deep Dive:** Giải thích hiện tượng "Write Skew" ở mức Isolation Serializable.
14. **Row-level Locking vs Table-level Locking:** Khi nào DB tự động escalate từ row lock lên table lock?
15. **Distributed ID:** Tại sao dùng UUID v4 làm Primary Key lại gây phân mảnh Index (Fragmentation)? Giải pháp (UUID v7, TSID)?
16. **Foreign Key Performance:** Tại sao thiếu Index ở cột Foreign Key lại gây deadlock hoặc table lock khi xóa cha/con?
17. **Full Text Search:** Inverted Index hoạt động thế nào trong ElasticSearch hoặc Postgres TSVECTOR?
18. **Bloom Filter:** Ứng dụng của Bloom Filter trong Cassandra/HBase để giảm thiểu việc đọc ổ cứng?
19. **Column-oriented DB (Cassandra/ClickHouse):** Tại sao nó nhanh hơn Row-oriented DB cho các query Analytics (OLAP)?
20. **LSM Tree (Log-Structured Merge-tree):** Cơ chế ghi dữ liệu của NoSQL (như Cassandra/RocksDB) khác gì B-Tree của SQL?
21. **Redis Pipelining:** Làm sao để tăng throughput khi gửi nhiều lệnh Redis cùng lúc?
22. **Redis Memory Optimization:** Sự khác nhau giữa `ziplist` và `skiplist`?
23. **Cache Eviction:** Khi Redis đầy bộ nhớ, nó xóa key dựa trên thuật toán nào? (Volatile-LRU, Allkeys-LRU...).
24. **Database Replication Lag:** Làm sao để giảm lag giữa Master và Slave?
25. **CDC (Change Data Capture):** Debezium hoạt động thế nào để bắt thay đổi từ DB log (Binlog/WAL)?
26. **Connection Pool Sizing:** Công thức nào để tính số lượng connection tối ưu? (Liên quan đến số Core CPU).
27. **SQL Anti-patterns:** Tại sao `OR` condition thường làm mất tác dụng của Index?
28. **Window Functions:** `RANK()` vs `DENSE_RANK()` vs `ROW_NUMBER()`? Ứng dụng phân trang hiệu năng cao.
29. **CTE (Common Table Expressions):** Recursive CTE dùng để làm gì (Query dữ liệu dạng cây)?
30. **Soft Delete Performance:** Tại sao query với điều kiện `WHERE is_deleted = false` thường bị chậm nếu index không tốt?
31. **Materialized View Refresh:** Các chiến lược refresh view (Complete vs Incremental)?
32. **Query Hint:** Khi nào bro cần ép buộc DB dùng một Index cụ thể?
33. **Data Archiving:** Chiến lược di chuyển dữ liệu lạnh (Cold Data) ra khỏi bảng chính để tăng tốc?
34. **Sharding Key Selection:** Hậu quả của việc chọn sai Sharding Key (Hotspot partition)?
35. **Database Migration:** Làm sao để migrate schema (thêm cột, đổi kiểu dữ liệu) cho bảng có 1 tỷ dòng mà không downtime? (Gợi ý: Expand-Contract pattern).